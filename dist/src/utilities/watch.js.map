{"version":3,"file":"watch.js","sourceRoot":"","sources":["../../../src/utilities/watch.ts"],"names":[],"mappings":"AAiBA;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,KAAK,CAAC,YAA+B,EAAE,OAAsB;IAC3E,MAAM,eAAe,GAA2B;QAC9C,oBAAoB,EAAE,KAAK;QAC3B,GAAG,OAAO;KACX,CAAC;IACF,OAAO,CACL,KAAgB,EAChB,eAAqD,EACrD,EAAE;QACF,oDAAoD;QACpD,MAAM,EAAE,MAAM,EAAE,GAAG,KAAK,CAAC;QACzB,MAAM,iBAAiB,GAAG,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC;YACnD,CAAC,CAAC,YAAY;YACd,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC;QAEnB,oDAAoD;QACpD,KAAK,CAAC,MAAM,GAAG,UAEb,YAA8D;YAE9D,iBAAiB,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE;gBACrC,MAAM,GAAG,GAAG,QAA2B,CAAC;gBACxC,IAAI,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;oBACzB,MAAM,QAAQ,GAAG,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBACvC,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;oBAE3B,IAAI,QAAQ,KAAK,QAAQ,EAAE;wBACzB,IAAI,CAAC,eAAe,CAAC,oBAAoB,IAAI,IAAI,CAAC,UAAU,EAAE;4BAC3D,IAAI,CAAC,eAAe,CAA8B,CACjD,QAAQ,EACR,QAAQ,CACT,CAAC;yBACH;qBACF;iBACF;YACH,CAAC,CAAC,CAAC;YAEH,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;QAClC,CAAC,CAAC;IACJ,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import type { LitElement } from \"lit\";\r\n\r\ntype UpdateHandler = (prev?: unknown, next?: unknown) => void;\r\n\r\ntype NonUndefined<A> = A extends undefined ? never : A;\r\n\r\ntype UpdateHandlerFunctionKeys<T extends object> = {\r\n  [K in keyof T]-?: NonUndefined<T[K]> extends UpdateHandler ? K : never;\r\n}[keyof T];\r\n\r\ninterface WatchOptions {\r\n  /**\r\n   * If true, will only start watching after the initial update/render\r\n   */\r\n  waitUntilFirstUpdate?: boolean;\r\n}\r\n\r\n/**\r\n * Runs when observed properties change, e.g. @property or @state, but before the component updates. To wait for an\r\n * update to complete after a change occurs, use `await this.updateComplete` in the handler. To start watching after the\r\n * initial update/render, use `{ waitUntilFirstUpdate: true }` or `this.hasUpdated` in the handler.\r\n *\r\n * Usage:\r\n *\r\n * @watch('propName')\r\n * handlePropChange(oldValue, newValue) {\r\n *   ...\r\n * }\r\n */\r\nexport function watch(propertyName: string | string[], options?: WatchOptions) {\r\n  const resolvedOptions: Required<WatchOptions> = {\r\n    waitUntilFirstUpdate: false,\r\n    ...options,\r\n  };\r\n  return <ElemClass extends LitElement>(\r\n    proto: ElemClass,\r\n    decoratedFnName: UpdateHandlerFunctionKeys<ElemClass>\r\n  ) => {\r\n    // @ts-expect-error - update is a protected property\r\n    const { update } = proto;\r\n    const watchedProperties = Array.isArray(propertyName)\r\n      ? propertyName\r\n      : [propertyName];\r\n\r\n    // @ts-expect-error - update is a protected property\r\n    proto.update = function (\r\n      this: ElemClass,\r\n      changedProps: Map<keyof ElemClass, ElemClass[keyof ElemClass]>\r\n    ) {\r\n      watchedProperties.forEach((property) => {\r\n        const key = property as keyof ElemClass;\r\n        if (changedProps.has(key)) {\r\n          const oldValue = changedProps.get(key);\r\n          const newValue = this[key];\r\n\r\n          if (oldValue !== newValue) {\r\n            if (!resolvedOptions.waitUntilFirstUpdate || this.hasUpdated) {\r\n              (this[decoratedFnName] as unknown as UpdateHandler)(\r\n                oldValue,\r\n                newValue\r\n              );\r\n            }\r\n          }\r\n        }\r\n      });\r\n\r\n      update.call(this, changedProps);\r\n    };\r\n  };\r\n}\r\n"]}